<html>
<head>
	<link rel="stylesheet" href="/style.css">
	<title>Maze Game</title>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
	<script type="text/javascript" src="https://static.codehs.com/gulp/a207eaf74c9a65ef1504f82657de97532616341f/chs-js-lib/chs.js"></script>
</head>

<body>
	<p align = "center">
		<canvas width="800" height="800" class="codehs-editor-canvas" style="background-color:black"></canvas>
	</p>
	
	<h2 id = "a"></h2>
	
<script>
window.onload = function() {
	removeAll();
	stopAllTimers();
	
	var blockSize = 20;
	var borderColor = Color.blue;
	var numBlocks = getHeight() / blockSize; // per row or col
	var totalBlocks = numBlocks * numBlocks - 1; // first square is blank
	var foodRadius = 3;
	var powerFoodRadius = foodRadius * 2;
	var powerColor = Color.cyan;
	var mazer, mazerCenter;
	var canMove = true;
	var mazerColor = Color.yellow;
	var enemyArray = [];
	var enemyColor = [ Color.red, Color.green, Color.orange, Color.purple ];
	var headRadius = 7, bodyWidth = headRadius * 2, bodyHeight = 8;
	
	function printX() { 
		document.getElementById("a").innerHTML = "Food Left: " + totalBlocks.toString(10);
	}
	function start() {
		printX(); ////////////////////////////
	
		mazeLayout();
		addCharacter();
		fillBoard();
		enemyArray[0] = new Enemy(blockSize * 10, blockSize * 10, enemyColor[0]);
		enemyArray[1] = new Enemy(blockSize * 11, blockSize * 10, enemyColor[1]);
		enemyArray[2] = new Enemy(blockSize * 12, blockSize * 10, enemyColor[2]);
		enemyArray[3] = new Enemy(blockSize * 13, blockSize * 10, enemyColor[3]);
		keyDownMethod(movement);
	}
	
	function mazeLayout() {
		for (var row = 0; row < numBlocks; row++) {
			for (var col = 0; col < numBlocks; col++) {
				addBorderBlock(col * blockSize, row * blockSize);
			}
		}
	}
	function fillBoard() {
		for (var row = 0; row < numBlocks; row++) {
			for (var col = 0; col < numBlocks; col++) {
				if (row == 0 && col == 0) // empty 0,0 square
					continue;
				else if (row == col)
					addFood(col * blockSize + blockSize/2, row * blockSize + blockSize/2, powerFoodRadius);
				else 
					addFood(col * blockSize + blockSize/2, row * blockSize + blockSize/2, foodRadius);
			}
		}
	}
	function addBorderBlock(xPos, yPos) {
		var block = new Rectangle (blockSize, blockSize);
		block.setBorderColor(borderColor);
		block.setPosition(xPos, yPos);
		add(block);
	}
	function addFood(xPos, yPos, radus) {
		var food = new Circle(radus);
		food.setColor(mazerColor);
		food.setPosition(xPos, yPos);
		add(food);
	}
	function addCharacter() {
		var startX = 0, startY = 0 
		var scale = 4;
		mazer = new Polygon();
		mazer.addPoint(startX + 0*scale, startY + 5*scale);
		mazer.addPoint(startX + 2.5*scale, startY + 0*scale);
		mazer.addPoint(startX + 5*scale, startY + 5*scale);
		mazerCenter = new Circle(foodRadius);
		mazerCenter.setPosition(startX + mazer.getWidth()/2, startY + mazer.getHeight()/2);
		mazer.setColor(mazerColor);
		add(mazerCenter); add(mazer);	
	}
	function movement(e) {
		if (totalBlocks == 0) { gameEnd("WIN"); }
		if (canMove) {
			if (e.keyCode == Keyboard.UP || e.keyCode == Keyboard.letter('W')) {
				if (mazerCenter.getY() - blockSize > 0) {
					mazer.move(0, -blockSize);
					mazerCenter.move(0, -blockSize);
				}
			}
			else if (e.keyCode == Keyboard.LEFT || e.keyCode == Keyboard.letter('A')) {
				if (mazerCenter.getX() - blockSize > 0) {
					mazer.move(-blockSize, 0);
					mazerCenter.move(-blockSize, 0);
				}
			}
			else if (e.keyCode == Keyboard.DOWN || e.keyCode == Keyboard.letter('S')) {
				if (mazerCenter.getY() + blockSize < getHeight()) {
					mazer.move(0, blockSize);
					mazerCenter.move(0, blockSize);
				}
			}
			else if (e.keyCode == Keyboard.RIGHT || e.keyCode == Keyboard.letter('D')) {
				if (mazerCenter.getX() + blockSize < getWidth()) {
					mazer.move(blockSize, 0);
					mazerCenter.move(blockSize, 0);
				}
			}
			var collideElem = getElementAt(mazerCenter.getX(), mazerCenter.getY());
			for (var i = 0; i < enemyColor.length; i++) {
				if (collideElem.getColor() == enemyColor[i]) {
					gameEnd("LOSE");
					break;
				}
			}
			if ((collideElem.getType() != "Polygon") && (collideElem.getColor() == "#FFFF00")) { // food
				if (collideElem.getRadius() == powerFoodRadius) { // power food
					//mazer.setColor(powerColor); // changes user to power color (can eat enemy)
					for (var i = 0; i < enemyArray.length; i++) {
						enemyArray[i].head.setColor(powerColor);
						enemyArray[i].body.setColor(powerColor);
					}
				}
				remove(collideElem); 
				totalBlocks--;
				printX(); ////////////////////////////
			}
			else if (collideElem.getColor() == "#00FFFF") { // eatable enemy 
				for (var i = 0; i < enemyArray.length; i++) {
					if (collideElem == enemyArray[i].head || collideElem == enemyArray[i].body){
						remove(enemyArray[i].head); remove(enemyArray[i].body);
					}
				}
			}
		}
	}
	class Enemy {
		constructor(xPos, yPos, color) {
			this.head = new Circle(headRadius);
			this.head.setColor(color); 
			this.head.setPosition(xPos + blockSize/2, yPos + blockSize/2); 
			add(this.head);
			this.body = new Rectangle(bodyWidth, bodyHeight);
			this.body.setColor(color); 
			this.body.setPosition(xPos + (blockSize - headRadius*2)/2, yPos + blockSize/2); 
			add(this.body);
			var enemyParts = []; enemyParts[0] = this.head; enemyParts[1] = this.body;
			setTimer(enemyMovement, 500, enemyParts);
		}
	}
	function enemyMovement(partsArray) { // 0:head, 1:body
		var randDirection = Randomizer.nextInt(1, 4);
		if (randDirection == 1) { // UP
			if (partsArray[0].getY() - blockSize > 0)
				partsArray[0].move(0, -blockSize); partsArray[1].move(0, -blockSize);
		}
		else if (randDirection == 2) { // LEFT
			if (partsArray[0].getX() - blockSize > 0)
				partsArray[0].move(-blockSize, 0); partsArray[1].move(-blockSize, 0);
		}
		else if (randDirection == 3) { // RIGHT
			if (partsArray[0].getX() + blockSize < getWidth())
				partsArray[0].move(blockSize, 0); partsArray[1].move(blockSize, 0);
		}
		else if (randDirection == 4) { // DOWN
			if (partsArray[1].getY() + blockSize < getHeight()) 
				partsArray[0].move(0, blockSize); partsArray[1].move(0, blockSize);
		}
	}
	
	function gameEnd(geText) {
		stopAllTimers();
		remove(mazerCenter);
		remove(mazer);
		canMove = false;
		var gameEndText;
		if (geText == "LOSE") { gameEndText = "Game Over"; }
		else if (geText == "WIN") { gameEndText = "Win!"; }
		var gameEnd = new Text (gameEndText, '50pt Arial');
		gameEnd.setPosition(getWidth()/2 - gameEnd.getWidth()/2, getHeight()/2);
		gameEnd.setColor(Color.white);
		gameEnd.setBorderColor(Color.black);
		var endBox = new Rectangle (gameEnd.getWidth(), gameEnd.getHeight());
		endBox.setPosition(getWidth()/2 - endBox.getWidth()/2, getHeight()/2 - endBox.getHeight());
		add(endBox);
		add(gameEnd);
	}
	
	if (typeof start == 'function')
		start();
}
</script>
	
</body>
</html>
